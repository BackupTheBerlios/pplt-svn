\documentclass[a4paper]{article}

%\usepackage[ngerman]{babel}								%Sprache
%\usepackage[ansinew]{inputenc}						%Umlaute ohne Maske
\usepackage{amsmath}											%Mathe für alle!
\usepackage{amsfonts}											%Mathefonts
\usepackage{graphicx}											%Bessere Grafikunterstüzung
\usepackage[pdfborder = 0 0 0]{hyperref}	%Nette PDFs ohne Müh...


\title{pyDCPU Core-Referece}
\author{Hannes Matuschek	}
\date{2005-03-15}


\begin{document}
	\begin{titlepage}
		\maketitle
		\vfill
		\tableofcontents
	\end{titlepage}
	\parindent = 0em
	\parskip = 2ex

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Hier Text einfügen...
\section{Init}
\subsection{Create a new CoreInstance}
This call will create a new CoreInstance (CoreObject). This is the core 
of the pyDCPU(PPLT) system. All work will be done by calling mehtods of
this object. Let's say it is important.
\begin{verbatim}
import pyDCPU
Core = pyDCPU.Core(ModuleDBFile, 
	                 UserDBFile, 
	                 LogFile = None,
	                 LogLevel = 'info',
	                 SysLog = False);
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{ModuleDBFile} &
		Path to the module database file (xml-file). This file contains all
	  known modules.\\ 
	\textbf{UserDBFile} &
		Path to the user/group database-file.\\
	\textbf{LogFile} &
		Path to the logfile. If \texttt{None} (default) all messages will be 
		written	to the \texttt{stderr}.\\
	\textbf{LogLevel} &
		The logging level. One of \texttt{debug}, \texttt{info}, \texttt{error},
		\texttt{fatal}, \texttt{off}. (default: \texttt{info})\\
	\textbf{SysLog} &
		If \texttt{True} all logging messages will be send to the local SysLog 
		daemon, even if a LogFile was specified.\\
	\textbf{RETURN} &
		Return a Core instance.
\end{tabular}




\section{Master Modules}
\subsection{Load a MasterModule}
\begin{verbatim}
ID = Core.MasterTreeAdd(ParentID,
			                  ModName,
			                  Address,
			                  Parameter);
\end{verbatim}

It is like "Load Module \texttt{ModName}, setup with \texttt{Parameter}, connect
it to \texttt{ParentID} with \texttt{Address}."

\begin{tabular}{l|p{8cm}}
	Name & Description \\ \hline \hline
	\textbf{ParentID} &
		The module will be attached to the module pointed by \texttt{ParentID}.\\
	\textbf{ModName} &
		Name of the Module to be loaded.\\
	\textbf{Address} &
		Some modules need a address if a child is attached to it. Set to \texttt{None}
		if not needed.\\
	\textbf{Parameter} &
		A \textit{dict} of name,value pairs. Used to control the behavior of the 
		module.\\
	\textbf{RETURN} &
		Return a new ObjectID. This id is used to attache other modules to it, 
		to destroy it, etc.
\end{tabular}




\subsection{Remove/Destroy a MasterModule.}
\begin{verbatim}
Core.MasterTreeDel(ObjectID);
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{ObjectID} &
		Destroy the Module pointed by the \texttt{ObjectID}. Note: Only Modules
		without children can be destroyed\\
	\textbf{RETURN} &
		Return \texttt{True} if the Object was sucessfully removed.
\end{tabular}




\subsection{Attach a SymbolSlot}
\begin{verbatim}
ObjectID = Core.MasterTreeAttachSymbolSlot(ParentID,
                                           Address,
                                           TypeName,
                                           TimeOut = 0.5)
\end{verbatim}

Read it like: "Attach a SymbolSlot to \texttt{ParentID} with \texttt{Address} 
as \text{TypeName} and a \texttt{TimeOut} cache time."

\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{ParentID} &
		The ID of the module the SymbolSlot will be attached to.\\
	\textbf{Address} &
		Like Address in \texttt{MasterTreeAdd()}.\\
	\textbf{TypeName} &
		Interpret the data of the parent module a this type.\\
	\textbf{TimeOut} &
		Cache the value for this time. (default: 0.5s)\\
	\textbf{RETURN} &
		Return the ObjectID for the Slot. The slot whill now be handled 
		like a normal module.
\end{tabular}




\subsection{List children of a MasterModule}
\begin{verbatim}
child_list = Core.MasterTreeList(ParentID)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{ParentID} &
		The ID of the module that childen-IDs you will get back.\\
	\textbf{RETURN} &
		Return a list of ObjectIDs.
\end{tabular}



\section{Export/Server Modules}
\subsection{Load a Export/Server Module}
\begin{verbatim}
ObjectID = Core.ExporterAdd(ExportModule, 
                            Paramerters, 
                            DefaultUser);
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{ExportModule} &
		Name of the export module.\\
	\textbf{Parameters} &
		Like \texttt{MasterTreeAdd()} this are the name, value pairs (dict)
		parameters to control the behavior of the module.\\
	\textbf{DefaultUser} &
		Some Export/Server protocols have no auth. so this user will always be used.
		Note: Choose a user with less rights, else it would be a security problem.\\
	\textbf{RETURN} &
		Return the new ObjectID of this loaded module.
\end{tabular}




\subsection{Unload/Stop a Export/Server Module}
\begin{verbatim}
Core.ExporterDel(ObjectID)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{ObjectID} &
		The ObjectID of the Export/ServerModule you want to stop.\\
	\textbf{RETURN} &
		Return \texttt{True} on sucess and \texttt{False} else.
\end{tabular}




\subsection{List all runing Export/ServerModules}
\begin{verbatim}
exporter_list = Core.ExporterList()
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{RETURN} &
		List of all runing Export/Server Modules.
\end{tabular}




\section{SymbolTree}
\subsection{Create Folder}
\begin{verbatim}
Core.SymbolTreeCreateFolder(Path)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path of the folder you want to create.\\
	\textbf{RETURN} &
		Retrun \texttt{True} on sucess.
\end{tabular}
		
		
\subsection{Delete Folder}
\begin{verbatim}
Core.SymbolTreeDeleteFolder(Path)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path of the folder you want to delete.\\
	\textbf{RETURN} &
		Retrun \texttt{True} on sucess.
\end{tabular}			
		
		
\subsection{Create a Symbol}
\begin{verbatim}
Core.SymbolTreeCreateSymbol(Path,
                            SymbolSlotID);
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path to the symbol you want to create.\\
	\textbf{SymbolSlotID} & 
		ID of the SymbolSlot\\
	\textbf{RETURN} &
		Return \texttt{True} on sucess, \texttt{False} otherwise.
\end{tabular}		
		
		
\subsection{Delete a Symbol}
\begin{verbatim}
Core.SymbolTreeDeleteSymbol(Path)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path to the symbol you want to delete.\\
	\textbf{RETURN} &
		Return \texttt{True} on sucess.
\end{tabular}
		
		
\subsection{List Symbols}
\begin{verbatim}
symbol_list = Core.SymbolTreeListSymbols(Path)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path to the folder you want to list.\\
	\textbf{RETURN}&
		Return a list of all symbols in folder given by \texttt{Path}.
\end{tabular}
		

\subsection{List Folders}
\begin{verbatim}
symbol_list = Core.SymbolTreeListFolders(Path)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path to the folder you want to list.\\
	\textbf{RETURN}&
		Return a list of all folders in folder given by \texttt{Path}.
\end{tabular}
		
		
\subsection{Get the permission}
\begin{verbatim}
(Owner, Group, Modus) = Core.SymbolTreeGetAccess(Path)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path to the symbol or folder.\\
	\textbf{Owner} &
		Username of the user who own this symbol or folder\\
	\textbf{Group} &
		Name of the group whitch the sysmbol or folder is attachted to.\\
	\textbf{Modus} &
		Interger like the Un*x file modus. Note: This integer has the base 10!\\
	\textbf{RETURN} &
		Returns a tupel of (Owner, Group, Modus).
\end{tabular}		


\subsection{Set the permission}
\begin{verbatim}
Core.SymbolTreeGetAccess(Path, Owner, Group, Modus)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path to the symbol or folder.\\
	\textbf{Owner} &
		Username of the user who own this symbol or folder\\
	\textbf{Group} &
		Name of the group whitch the sysmbol or folder is attachted to.\\
	\textbf{Modus} &
		Interger like the Un*x file modus. Note: This integer has the base 10!\\
	\textbf{RETURN} &
		Returns \texttt{True} on sucsess.
\end{tabular}		

		
\subsection{Get value}
\begin{verbatim}
value = Core.SymbolTreeGetValue(Path)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path to the symbol.\\
	\textbf{RETURN}&
		Return the value of the symbol or \texttt{None} on error.
\end{tabular}		
		
		
\subsection{Set Value}
\begin{verbatim}
Core.SymbolTreeSetValue(Path, 
                        Value)
\end{verbatim}
\begin{tabular}{l|p{8cm}}
	Name & Description\\ \hline \hline
	\textbf{Path} &
		The complete path to the symbol.\\
	\textbf{Value} &
		The value you want to set.\\
	\textbf{RETURN} &
		Return \texttt{True} on success or \texttt{False} on error.
\end{tabular}

\end{document}
